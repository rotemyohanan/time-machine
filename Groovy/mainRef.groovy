
GroovyMainReference

Differences with Java

Default imports
Multi methods:  method is chosen based on the types of the arguments at runtime

Groovy:
the method will be chosen based on the types of the arguments at runtime.
Java:
methods are chosen at compile time, based on the declared types.


The { …​ } block is reserved for closures.

Omitting a modifier on a field doesn’t result in a package-private field like in Java.
Default variable’s modifier is private.

class Person {
    @PackageScope String name
}

Inner class must be static.

GString
(“ ”) Double-quoted string literals are interpreted as GString.
Typically, Groovy will auto-cast between GString and String
(‘ ‘) Singly-quoted literals in Groovy are used for String. 

Groovy will automatically cast a single-character String to char.

Groovy uses Objects for everything.

It autowraps references to primitives (By default)

Java: widening has precedence over unboxing hence int will change to long first before it will change to Integer (when there is the decision to make).


11. Behaviour of ==

In Java == means equality of primitive types or identity for objects. 
In Groovy == translates to a.compareTo(b)==0, iff they are Comparable, and a.equals(b) otherwise. 
To check for identity, use is. E.g. a.is(b).

Extra keywords:
as , def , in , trait


The Groovy Development Kit

That is the path for reading files from the project.
new File( "/Users/rotemyochanan/Work/SandBox/src/groovy", 'text.txt').eachLine { line ->
            println line
}

1.3. Traversing file trees

In scripting contexts


2. Working with collections
various collection types, including lists, maps or ranges

Keep reading from sorting

Syntax

Strings:

String - java.lang.String
GStrings - groovy.lang.GString 

Triple single quoted:  
'''a triple single quoted string'''
Triple single quoted strings are plain java.lang.String and don’t support interpolation.
Can be multiline.

Escaping special characters: by using the ‘\’ before the character.






Groovy - general
Groovy is a dynamic language and by default Groovy uses a dynamic dispatch mechanism to carry out method calls and property access.
This dynamic dispatch mechanism provides a lot of flexibility and power to the language. For example, it is possible to dynamically add methods to classes at runtime and it is possible to dynamically replace existing methods at runtime. Features like these are important and provide a lot of power to the language. However, there are times when you may want to disable this dynamic dispatch in favor of a more static dispatch mechanism and Groovy provides a way to do that. The way to tell the Groovy compiler that a particular class should compiled statically is to mark the class with the groovy.transform.CompileStatic annotation as shown below.

import groovy.transform.CompileStatic
@CompileStatic
class MyClass {

    // this class will be statically compiled...

}


@TypeChecked - defines optional type checking
The type checker runs at compile time and performs a static analysis of dynamic code. 

This annotation turns the Groovy compiler into a static compiler, where all method calls are resolved at compile time and the generated bytecode makes sure that this happens: the annotation is @groovy.transform.CompileStatic.
